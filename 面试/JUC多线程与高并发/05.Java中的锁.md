## 公平与非公平锁

公平和非公平是什么意思？，这是类似排队来说

- **公平**：上公交车时有序排队，一个个按顺序上
- **非公平**：上公交车时人挤人，谁力气大位置好谁先挤进去

对锁来说就是：

- **公平锁**：并发情况下，多个线程排队使用锁，会进入队列中，先进先出的顺序来获取锁
- **非公平锁**：并发情况下，并不按照顺序来获取锁，谁抢到就是谁的

Java中最基础的锁有两种，Synchronize和ReentrantLock。

- `Synchronize`：非公平锁
- `ReentrantLock`：再构造时可以传入boolean值参数
  - **true**：公平锁
  - **false**：非公平锁（默认）

```java
/**
* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
*/
Lock lock = new ReentrantLock(true);
```

非公平锁会比公平锁有更大的吞吐量，两者根据业务需求选择使用

## 可重入锁

可重复锁又叫递归锁，这个锁概念其实很简单，就一句话：**线程可以进入所有他已经获取锁的同步代码块**

什么意思呢？一个线程在外层函数获取到锁之后，内部调用的其他方法都会直接执行，不需要重新获取锁，使用最外层获取到的锁就可以。

用代码来解释一下：

```java
public synchronized void method1() {
    method2();
}

public synchronized void method2() {
}
```

我们可以看到，method1和2都加了锁，我们获取到锁进入method1后，在method1调用method2不需要等待获取锁，而是可以直接执行，使用一开始获取的锁就可以，使用的是同一把锁。

用个更简单的例子：你回家，只需要用一把钥匙开了你家的大门，进去之后再进厨房，卫生间，卧室就都不需要开锁了，直接进就可以。

### 代码验证

**首先验证Synchronize**

```java
class House{
    public synchronized void goDoor(){
        System.out.println(Thread.currentThread().getName() + "进家门了");
        goCook();
    }
    public synchronized void goCook(){
        System.out.println(Thread.currentThread().getName() + "进厨房看");
    }
}
public class ReenterLockDemo {
    public static void main(String[] args) {
        House house = new House();
        new Thread(() -> {
            house.goDoor();
        },"t1").start();

        new Thread(() -> {
            house.goDoor();
        },"t2").start();
    }
}
```

![image-20210111173904431](image/image-20210111173904431.png)

可以看到，t1获取到锁之后，直接就使用同一把锁执行了goCook方法，证明可重入锁

**验证ReentrantLock**

```java
class HouseThread implements Runnable {

    Lock lock = new ReentrantLock();

    public void goDoor(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "进家门了");
            goCook();
        } finally {
            lock.unlock();
        }
    }

    private void goCook() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "进厨房看");
        } finally {
            lock.unlock();
        }
    }

    @Override
    public void run() {
        goDoor();
    }
}
public class ReenterLockDemo {
    public static void main(String[] args) {
        HouseThread houseThread = new HouseThread();
        Thread t3 = new Thread(houseThread);
        Thread t4 = new Thread(houseThread);
        t3.start();
        t4.start();
    }
}
```

![image-20210111174436369](image/image-20210111174436369.png)



