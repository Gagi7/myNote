## 负载均衡介绍

负载均衡这个概念其实很简单，我们先举个生活中的例子，薅羊毛：

有一群羊，你要薅100根羊毛，如何选择羊就是负载均衡要干的事，100根羊毛就相当于100个请求，一群羊就是服务节点，如果没有负载均衡，我们只挑一群羊中的某个羊狠狠地薅，就成下面这个样子了：

![image-20201023101443535](image/image-20201023101443535.png)

所以**负载均衡就是将请求均匀的分发到每个服务节点上**。

负载均衡的核心概念：

- 雨露均沾
- 不能让某个节点特别累
- 要累就一起累

负载均衡相当重要，为什么呢？看看下面这个系统：

<img src="image/image-20201023101849516.png" alt="image-20201023101849516" style="zoom:60%;" />

淘宝的UMP系统，也就是计算折扣优惠的系统，在淘宝主链路中起着相当重要的角色，所以他的并发量请求量也是非常大的，可以排在淘宝全部服务的Top5。

这么一个大并发量的系统，其背后的集群节点肯定数不胜数，就一个微服务就需要5000台机器来支持，如果没有负载均衡，**那5000台机器你要怎么选择？就要依靠负载均衡**

<img src="image/image-20201023102133883.png" alt="image-20201023102133883" style="zoom:67%;" />

还有一点，平常的时候我们部署5000台集群，但是如果到了618双十一，就要双倍三倍的集群节点增加，那么请问：**虚拟机添加，对单机性能有没有影响？没有**，不管你怎么加，单机的性能就是那样的，那为什么要加机器？因为我们**实际承接的性能是单机乘以节点数量，这些都是依靠负载均衡实现的**，如果没有负载均衡，你节点加的再多，可能请求到的就只有几台几十台。

所以，**负载均衡是一个很简单的概念，实现起来也简单，但他的作用绝对不简单**

### 客户端与服务端

负载均衡具有客户端负载均衡实现与服务端负载均衡实现两种，两种各有各的好处。

**客户端负载均衡**：

<img src="image/image-20201023103449474.png" alt="image-20201023103449474" style="zoom:60%;" />

客户端可以获取所有服务节点的机器列表，如Eureka，客户端可以获取注册中心的所有可用服务列表，然后通过自己制定的负载均衡策略，可以获知该请求的服务节点进行请求。

主要有三点：

- 机器列表保存在客户端
- 机器列表是动态变化的
- 负载均衡策略由客户端自己制定

**服务端负载均衡**：

<img src="image/image-20201023103830857.png" alt="image-20201023103830857" style="zoom:67%;" />



服务端负载均衡依靠一个中间件来实现，客户端是没有机器列表的，客户端的请求会发送到中间服务端负载均衡组件，然后就等着响应就可以了，实际负载均衡以及请求后面的服务节点获取数据，都是由服务端负载均衡组件实现的。客户端更轻松，少了负载均衡任务

**客户端与服务端优缺点**：

<img src="image/image-20201023104140892.png" alt="image-20201023104140892" style="zoom:67%;" />

- 客户端负载均衡策略是编写在客户端里的，所以对于开发团队来说修改灵活，随意修改，但是服务端的负载均衡一般是由运维团队修改的，开发团队没有权限进行修改
- 客户端运维成本低，和之前一样jar包部署即可，但是服务端无意义添加了一个工作项，所以成本也就提高了
- 客户端要保存服务列表在自身，所以需要向注册中心拉取，所以强依赖与注册中心，而服务端不依赖
- 客户端一般来说都是鱼微服务框架在一起的，比如Ribbon，Feign，Hystrix；而服务端都是与传统Tomcat绑定使用

那么我们应该如何选择呢？当然是**客户端+服务端一起使用**，这样负载均衡策略更加完整，并发性能更高

## 初识Ribbon

Ribbon其实是一个简单的小组件，用于负载均衡

我们拿小时候的经典动画片，圣斗士星矢来举例子，黄金圣衣是最厉害的装备，其中天秤座圣衣是最特殊的一件，因为他有几个特点：<img src="image/image-20201023113257735.png" alt="image-20201023113257735" style="zoom:50%;" />

- 丰富的武器库，由12件兵器组成，煎炸烹炒样样精通
- 适配性好，谁穿都行，五小强谁都可以用

Ribbon就像天秤座圣衣一样，有着一模一样的特点：

- **丰富的组件库** 整套负载均衡由7个具体策略组成，不管你是什么特殊需求，都有合适的策略供你选择
- **给谁都能用** 适配性好，跟谁都能搭配，SpringCloud里的五小强（eureka，feign，gateway，zuul，hystrix），谁拿都能用

更牛的是Ribbon可以脱离SpringCloud单独在项目中使用~

## 走近Ribbon

既然谁都可以用，我们上一节刚学了Eureka，我们看看Eureka是如何和Ribbon组合使用的，如下图，其中红边白底的是Ribbon的组件

<img src="image/image-20201023114014576.png" alt="image-20201023114014576" style="zoom:57%;" />

请求进来，到Eureka Client消费，Eureka通过服务发现获取到一大堆的服务地址，但是他不知道调用哪个，这个任务就交给Ribbon来完成了。

- IPing：这是一个healthcheck机制，用来Ping一下目标机器是否还在线的，一般情况下IPing不会主动发起healthcheck请求，而是使用静默处理，返回true就默认表示所有节点都可用（和Eureka集成的时候，会检测节点的UP状态）
- IRule：这就是负载均衡组件库了，他是一个规则接口，有大量的负载均衡实现类，会有一个默认的实现类，当请求过来后，就会调用IRule接口，实际使用默认的实现类或配置的实现类，来进行负载均衡策略选择一台服务节点进行调用，把请求转发过去

Ribbon的体系架构相对简单，职责也比较单一，只应用于负载均衡，知识点不多，因此特别适合快速通关。考虑到Ribbon和Hystrix以及Feign有千丝万缕的关系，因此，关于Ribbon的retry部分知识，我将放到Feign和Hystrix中来展开

## 实现Ribbon

Ribbon是一个很简单的组件，实现起来也非常简单，我们这里先简单的使用它最基本的负载均衡功能，尝试一下

我们在之前的`spring-cloud-study`工程下创建`ribbon\ribbon-counsumer`模块

1.添加依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

2.添加配置文件

```yml
spring:
  application:
    name: ribbon-consumer
server:
  port: 31000
eureka:
  client:
    service-url:
      defaultZone: http://localhost:22222/eureka
```

3.添加Controller

```java
@RestController
public class Controller {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/sayHi")
    public String sayHi(){
        String result = restTemplate.getForObject("http://eureka-client/sayHi", String.class);
        return result;
    }
}
```

这里可以发现，和我们之前的Eureka-client没什么区别嘛，是的，因为它使用起来真得很简单，只需要下面一步

4.添加Application

```java
@SpringBootApplication
@EnableDiscoveryClient
public class RibbonClientApplication {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    public static void main(String[] args) {
        SpringApplication.run(RibbonClientApplication.class,args);
    }
}
```

没错，就一个@LoadBalanced注解即可，这样就赋予了RestTemplate负载均衡的能力~

5.测试

开启注册中心，开启两个Eureka-Client，修改端口，分别以30000和30001启动，最后启动Ribbon-Consumer

打开注册中心，会发现3个节点注册上去

![image-20201023142817078](image/image-20201023142817078.png)

然后就可以访问 http://localhost:31000/sayHi 测试

<img src="image/image-20201023142837742.png" alt="image-20201023142837742" style="zoom:80%;" /><img src="image/image-20201023142843643.png" alt="image-20201023142843643" style="zoom:80%;" />

然后会发现会轮训的访问两个节点，说明负载均衡成功，Ribbon使用成功

## Ribbon高级知识点

### Ribbon懒加载

Ribbon是懒加载的，即第一次调用方法时，才会去加载LoadBalancer，可以通过日志发现：

![image-20201023144906487](image/image-20201023144906487.png)

在13秒的时候项目就启动起来了，但是当我们29秒请求接口的时候，再开始下面那句初始化LoadBalancer，所以他是懒加载的。

那么这种懒加载会不会出现问题呢？有可能，如果你第一个访问的接口耗时比较长，因为第一次需要初始化LoadBalancer，所以初始化时间+接口访问时间有可能会超出超时时间，导致访问失败。

那么有没有办法不让他懒加载呢？可以，使用以下配置：开启饥饿加载

```yml
ribbon:
  eager-load:
    clients: ribbon-cousumer # 开启的ribbon服务名称，就是当前服务名称
    enabled: true
```

然后查看日志

![image-20201023145710477](image/image-20201023145710477.png)

启动后就直接初始化了

### 修改负载均衡策略

这里我们先简单介绍两个负载均衡策略，以便我们修改，更多的负载均衡策略我们在下一小节详细介绍：

- RandomRule：顾名思义，随机访问
- RoundRobinRule：轮训访问

接着我们就来看看如何修改默认的负载均衡策略，这里主要有三种方式

#### 全局配置

```java
@Configuration
public class RibbonLSConfig {

    @Bean
    public IRule defaultLBStrategy(){
        return new RandomRule();
    }
}
```

想要使用什么策略，就new什么策略返回

#### 服务维度配置

服务维度配置有两种方式，基于注解与基于配置文件的

基于配置文件：

```yml
# 修改服务维度负载均衡策略
# 服务名称 + ribbon + NFLoadBalancerRuleClassName : 策略全限定类名
eureka-client:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

基于注解实现：

```java
@RibbonClient(name = "eureka-client",configuration = com.netflix.loadbalancer.RandomRule.class)
```

需要注意：

- 全局维度优先级大于服务维度的，即配置了全局维度，服务维度就不再生效了
- 注解实现的服务维度优先级高于配置文件实现

#### 方法维度配置

方法维度我们放在后面学习Feign的时候实现

### 负载均衡策略们

#### RandomRule

随机选择节点访问，看上去很简单，随便想一下就能知道他的原理，但其实不是那么简单，它底层使用了**自旋锁+yield**的方式进行重试，并编写了大量防御性编程，都是我们可以学习的。

让我们瞅瞅它的源码：

```java
public class RandomRule extends AbstractLoadBalancerRule {
    public RandomRule() {
    }

    @SuppressWarnings({"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE"})
    public Server choose(ILoadBalancer lb, Object key) {
        // 防御性编程。判断负载均衡对象是否存在
        if (lb == null) {
            return null;
        } else {
            Server server = null;
            // 自旋锁
            while(server == null) {
                /* 注意这里，判断线程是否断开
                *  为什么要这么判断呢？因为在下面有一个yield()方法
                *  当取不到可用服务时，让给其他线程，此时该线程就断开了
                *  所以直接返回null
                *  这样其他线程再进来获取服务，就实现了重试机制
                * */
                if (Thread.interrupted()) {
                    return null;
                }

                // 获取所有可用服务列表
                List<Server> upList = lb.getReachableServers();
                // 获取所有服务列表
                List<Server> allList = lb.getAllServers();
                int serverCount = allList.size();
                // 如果不存在服务列表，返回null，防御性编程
                if (serverCount == 0) {
                    return null;
                }

                // 调用chooseRandomInt方法，传入种子为服务数，生成随机数
                int index = this.chooseRandomInt(serverCount);
                // 从可用列表中获取该随机数的服务
                server = (Server)upList.get(index);
                // 判断服务是否存在，防御性编程
                if (server == null) {
                    /* 重点！
                    *  如果服务不存在，使用yield把资源让给别的线程来请求
                    * */
                    Thread.yield();
                    continue;
                } else {
                    // 如果服务存活，返回服务
                    if (server.isAlive()) {
                        return server;
                    }

                    // 如果服务不存活，将服务置为null并线程出让
                    // 这样下个线程进来，依旧可以进入while循环
                    server = null;
                    Thread.yield();
                }
            }

            return server;
        }
    }

    protected int chooseRandomInt(int serverCount) {
        return ThreadLocalRandom.current().nextInt(serverCount);
    }

    // 外层调用的方法，实际调用重载方法
    public Server choose(Object key) {
        return this.choose(this.getLoadBalancer(), key);
    }

    public void initWithNiwsConfig(IClientConfig clientConfig) {
    }
}
```

通过源码可以看到，**RandomRule使用自旋锁(while(server == null))+yield实现重试策略，非常巧妙**，并且编写了大量防御性编程，也是非常好的一种习惯，**防御性编程就是防范于未然，虽然你知道服务列表不可能为空，还是要判断一下**

#### RoundRobinRule

RoundRobinRule是轮训访问服务节点，听着很简单，也有大道理，既然是轮训就肯定有线程安全问题，不然顺序就错乱了，其底层使用**自旋锁+CAS保证线程安全**，就是我们需要学习的点

```java
public class RoundRobinRule extends AbstractLoadBalancerRule {
    private AtomicInteger nextServerCyclicCounter;
   
    // ···

    public RoundRobinRule() {
        // 初始化下标从第0个开始
        this.nextServerCyclicCounter = new AtomicInteger(0);
    }

    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            log.warn("no load balancer");
            return null;
        }
        Server server = null;
        int count = 0;

        // 这里和RandomRule不同，最多次数为10次，超出10次后会跳出
        while(server == null && count++ < 10) {
            List<Server> reachableServers = lb.getReachableServers();
            List<Server> allServers = lb.getAllServers();
            int upCount = reachableServers.size();
            int serverCount = allServers.size();

            // 判断服务器是否为空
            if (upCount != 0 && serverCount != 0) {
                // 使用自旋锁+CAS保证线程安全，获取下一个地址下标
                int nextServerIndex = this.incrementAndGetModulo(serverCount);
                // 获取服务
                server = (Server)allServers.get(nextServerIndex);
                // 判断服务
                if (server == null) {
                    Thread.yield();
                } else {
                    if (server.isAlive() && server.isReadyToServe()) {
                        return server;
                    }

                    server = null;
                }
                continue;
            }

            log.warn("No up servers available from load balancer: " + lb);
            return null;
        }
        if (count >= 10) {
            log.warn("No available alive servers after 10 tries from load balancer: " + lb);
        }

        return server;
    }

    // 重点就在这个方法，使用自旋锁+CAS实现线程安全的获取下一次地址
    private int incrementAndGetModulo(int modulo) {
        // 自旋锁
        for(;;){
            // 从AtomicInteger中获取当前下标，第一次进入的时候是0
            int current = this.nextServerCyclicCounter.get();
            // 获取下一次下标，(当前下标+1)%所有节点数
            int next = (current + 1) % modulo;
            /* 使用CAS操作，保证线程安全
            *  底层调用 unsafe.compareAndSwapInt()方法 该方法是由native修饰的，即是基于操作系统的编程实现，与Java无关
            *  这个方法主要是判断当前底层保存的这个数，和传入的第一个也就是current是否相等
            *  类似乐观锁机制，如果相等直接返回，不相等设置为第二个数即next
            *  这里会发现有两步操作，比较，设置，那还是原子性操作吗？底层这两部操作其实是一步操作，所以是原子性的
            * */
            if(this.nextServerCyclicCounter.compareAndSet(current, next))
                return next;
        }
    }

    public Server choose(Object key) {
        return this.choose(this.getLoadBalancer(), key);
    }

    public void initWithNiwsConfig(IClientConfig clientConfig) {
    }
}
```

通过源码阅读，我们会发现自旋锁+CAS听着高深，但其实是很简单实现线程安全的一种方式，在Netflix中，大量使用了这种机制

**这里有一个问题**

如果有4000台服务节点全部挂掉，当轮训进来时，每次都会从第一个节点开始判断是否可用，那么大量并发进来后，全部挤压到第一台，然后第二台，然后第三台，这样就会给机器带来更大的压力了，应该如何解决呢？

#### BestAvailableRule

该规则为找到非熔断最空闲的服务，话不多说，先看代码

```java
public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule {
    private LoadBalancerStats loadBalancerStats;

    public BestAvailableRule() {
    }

    public Server choose(Object key) {
        // 如果当前loadBalancerStats负载均衡状态为null，使用父类的choose方法
        // 父类的choose方法是什么？通过继承类ClientConfigEnabledRoundRobinRule可以知道
        // 使用的是RoundRobinRule
        if (this.loadBalancerStats == null) {
            return super.choose(key);
        } else {
            // 获取所有服务
            List<Server> serverList = this.getLoadBalancer().getAllServers();
            // 设置最小的当前连接数为 最大值，为什么这么做？往后看
            int minimalConcurrentConnections = Integer.MAX_VALUE;
            // 获取当前时间，有什么用？ 往后看
            long currentTime = System.currentTimeMillis();
            Server chosen = null;
            // 循环Server列表，寻找最合适的服务
            for(Server server : serverList){
                // 获取当前服务的服务状态
                ServerStats serverStats = loadBalancerStats.getSingleServerStat(server);
                /* 重点一：判断该服务状态是否处于熔断状态 */
                if (!serverStats.isCircuitBreakerTripped(currentTime)) {
                    // 获取该服务的当前连接数
                    int concurrentConnections = serverStats.getActiveRequestsCount(currentTime);
                    /* 重点二：判断当前服务连接数，是否小于最小连接数
                    *  如果是，将最小连接数设置为当前服务连接数，并且将选择的服务设置为当前服务
                    *  这样，不断循环所有服务，就可以找到最空闲的服务返回
                    *  */
                    if (concurrentConnections < minimalConcurrentConnections) {
                        minimalConcurrentConnections = concurrentConnections;
                        chosen = server;
                    }
                }
            }

            // 如果没有选择到服务，使用轮训获取下一服务
            if (chosen == null) {
                return super.choose(key);
            } else {
                return chosen;
            }
        }
    }

    public void setLoadBalancer(ILoadBalancer lb) {
        super.setLoadBalancer(lb);
        if (lb instanceof AbstractLoadBalancer) {
            this.loadBalancerStats = ((AbstractLoadBalancer)lb).getLoadBalancerStats();
        }

    }
}
```

通过源码查看，我们会发现当loadBalancerStats不存在的时候，会使用RoundRobinRule策略进行选择，并且发现两个重点，第二个重点我们很清晰了，就是依靠连接数循环获取最空闲的服务，第一个重点判断是否熔断是怎么实现的呢？我们再看源码：

```java
public boolean isCircuitBreakerTripped(long currentTime) {
    // 获取当前熔断结束时间
    long circuitBreakerTimeout = getCircuitBreakerTimeout();
    // 如果不存在，小于0，返回false
    if (circuitBreakerTimeout <= 0) {
        return false;
    }
    // 判断熔断结束时间是否大于当前时间，大于返回true表示还在熔断状态，小于返回false，表示不处于
    return circuitBreakerTimeout > currentTime;
}
```

然后进入getCircuitBreakerTimeout，查看如何获取熔断超时时间

```java
// 获取熔断结束时间
private long getCircuitBreakerTimeout() {
    // 获取熔断时间
    long blackOutPeriod = getCircuitBreakerBlackoutPeriod();
    if (blackOutPeriod <= 0) {
        return 0;
    }
    // 用最后一次失败请求时间+熔断时间，为熔断结束时间
    return lastConnectionFailedTimestamp + blackOutPeriod;
}

// 获取熔断时间
private long getCircuitBreakerBlackoutPeriod() {
    // 每次请求都会保存在successiveConnectionFailureCount这个缓存数中
    // 获取失败次数
    int failureCount = successiveConnectionFailureCount.get();
    // 获取阈值
  	// 阈值从niws.loadbalancer.default.connectionFailureCountThreshold配置中获取，如果没有默认为3
    int threshold = connectionFailureThreshold.get();
    // 判断失败次数是否超出阈值，如果没有，则不熔断
    if (failureCount < threshold) {
        return 0;
    }
    // 接下来用来计算熔断时间，基本也是从配置或默认值中取来计算
    int diff = (failureCount - threshold) > 16 ? 16 : (failureCount - threshold);
    int blackOutSeconds = (1 << diff) * circuitTrippedTimeoutFactor.get();
    if (blackOutSeconds > maxCircuitTrippedTimeout.get()) {
        blackOutSeconds = maxCircuitTrippedTimeout.get();
    }
    // 返回熔断时间
    return blackOutSeconds * 1000L;
}
```

通过源码，我们基本知道了Ribbon此规则，是如何计算服务是否熔断以及熔断时间的，就是根据该服务失败请求是否超出阈值来判断。

我们再回过头**总结该策略**：

- 基于RoundRobinRule，如果获取不到LoadBalancerStats时，**使用轮训**
- 循环服务节点
  - **判断该服务是否熔断**，用失败请求是否超出阈值（默认为3）来判断，并计算熔断结束时间是否已经结束
  - 如果服务正常，**获取最小连接数**，连接数最小即并发量最小的被选中为服务节点
- 如果循环找不出服务节点，**还是使用轮训获取**